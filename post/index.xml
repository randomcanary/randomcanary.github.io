<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Random Canary</title>
    <link>http://randomcanary.github.io/post/</link>
    <description>Recent content in Posts on Random Canary</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 08 Mar 2016 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://randomcanary.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Code Sample</title>
      <link>http://randomcanary.github.io/post/2016-03-08-code-sample/</link>
      <pubDate>Tue, 08 Mar 2016 00:00:00 +0000</pubDate>
      
      <guid>http://randomcanary.github.io/post/2016-03-08-code-sample/</guid>
      <description>&lt;p&gt;The following is a code sample using the &amp;ldquo;highlight&amp;rdquo; shortcode provided in Hugo.&lt;/p&gt;

&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;    &lt;span class=&#34;kd&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;num1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;num2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;sum&lt;/span&gt;
    &lt;span class=&#34;nx&#34;&gt;num1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;prompt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;quot;Enter first number&amp;quot;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
    &lt;span class=&#34;nx&#34;&gt;num2&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;prompt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;quot;Enter second number&amp;quot;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
    &lt;span class=&#34;nx&#34;&gt;sum&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;parseInt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;num1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;parseInt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;num2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// &amp;quot;+&amp;quot; means &amp;quot;add&amp;quot;&lt;/span&gt;
    &lt;span class=&#34;nx&#34;&gt;alert&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;quot;Sum = &amp;quot;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;sum&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;// &amp;quot;+&amp;quot; means combine into a string&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

</description>
    </item>
    
    <item>
      <title>Flake it till you make it</title>
      <link>http://randomcanary.github.io/post/2015-02-26-flake-it-till-you-make-it/</link>
      <pubDate>Thu, 26 Feb 2015 00:00:00 +0000</pubDate>
      
      <guid>http://randomcanary.github.io/post/2015-02-26-flake-it-till-you-make-it/</guid>
      <description>&lt;p&gt;Under what circumstances should we step off a path? When is it essential that we finish what we start? If I bought a bag of peanuts and had an allergic reaction, no one would fault me if I threw it out. If I ended a relationship with a woman who hit me, no one would say that I had a commitment problem. But if I walk away from a seemingly secure route because my soul has other ideas, I am a flake?&lt;/p&gt;

&lt;p&gt;The truth is that no one else can definitively know the path we are here to walk. It’s tempting to listen—many of us long for the omnipotent other—but unless they are genuine psychic intuitives, they can’t know. All others can know is their own truth, and if they’ve actually done the work to excavate it, they will have the good sense to know that they cannot genuinely know anyone else’s. Only soul knows the path it is here to walk. Since you are the only one living in your temple, only you can know its scriptures and interpretive structure.&lt;/p&gt;

&lt;p&gt;At the heart of the struggle are two very different ideas of success—survival-driven and soul-driven. For survivalists, success is security, pragmatism, power over others. Success is the absence of material suffering, the nourishing of the soul be damned. It is an odd and ironic thing that most of the material power in our world often resides in the hands of younger souls. Still working in the egoic and material realms, they love the sensations of power and focus most of their energy on accumulation. Older souls tend not to be as materially driven. They have already played the worldly game in previous lives and they search for more subtle shades of meaning in this one—authentication rather than accumulation. They are often ignored by the culture at large, although they really are the truest warriors.&lt;/p&gt;

&lt;p&gt;A soulful notion of success rests on the actualization of our innate image. Success is simply the completion of a soul step, however unsightly it may be. We have finished what we started when the lesson is learned. What a fear-based culture calls a wonderful opportunity may be fruitless and misguided for the soul. Staying in a passionless relationship may satisfy our need for comfort, but it may stifle the soul. Becoming a famous lawyer is only worthwhile if the soul demands it. It is an essential failure if you are called to be a monastic this time around. If you need to explore and abandon ten careers in order to stretch your soul toward its innate image, then so be it. Flake it till you make it.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Test markdown</title>
      <link>http://randomcanary.github.io/post/2015-02-20-test-markdown/</link>
      <pubDate>Fri, 20 Feb 2015 00:00:00 +0000</pubDate>
      
      <guid>http://randomcanary.github.io/post/2015-02-20-test-markdown/</guid>
      <description>

&lt;p&gt;You can write regular &lt;a href=&#34;http://markdowntutorial.com/&#34;&gt;markdown&lt;/a&gt; here and Jekyll will automatically convert it to a nice webpage.  I strongly encourage you to &lt;a href=&#34;http://markdowntutorial.com/&#34;&gt;take 5 minutes to learn how to write in markdown&lt;/a&gt; - it&amp;rsquo;ll teach you how to transform regular text into bold/italics/headings/tables/etc.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Here is some bold text&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&#34;here-is-a-secondary-heading:a5ed5ad469075de9496b4e56da932831&#34;&gt;Here is a secondary heading&lt;/h2&gt;

&lt;p&gt;Here&amp;rsquo;s a useless table:&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;Number&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Next number&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Previous number&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Five&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Six&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Four&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Ten&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Eleven&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Nine&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Seven&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Eight&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Six&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Two&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Three&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;One&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;How about a yummy crepe?&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://lafenicegelato.com/wp-content/uploads/2014/09/crepes-with-chocolate.jpg&#34; alt=&#34;Crepe&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s a code chunk:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;x &amp;lt;- 5 + 10
print(x)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And here is some code with syntax highlighting&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var foo = function(x) {
  return(x + 5);
}
foo(3)
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>To be</title>
      <link>http://randomcanary.github.io/post/2015-02-13-hamlet-monologue/</link>
      <pubDate>Fri, 13 Feb 2015 00:00:00 +0000</pubDate>
      
      <guid>http://randomcanary.github.io/post/2015-02-13-hamlet-monologue/</guid>
      <description>&lt;p&gt;To be, or not to be&amp;ndash;that is the question:
Whether &amp;lsquo;tis nobler in the mind to suffer
The slings and arrows of outrageous fortune
Or to take arms against a sea of troubles
And by opposing end them. To die, to sleep&amp;ndash;
No more&amp;ndash;and by a sleep to say we end
The heartache, and the thousand natural shocks
That flesh is heir to. &amp;lsquo;Tis a consummation
Devoutly to be wished. To die, to sleep&amp;ndash;
To sleep&amp;ndash;perchance to dream: ay, there&amp;rsquo;s the rub,
For in that sleep of death what dreams may come
When we have shuffled off this mortal coil,
Must give us pause. There&amp;rsquo;s the respect
That makes calamity of so long life.
For who would bear the whips and scorns of time,
Th&amp;rsquo; oppressor&amp;rsquo;s wrong, the proud man&amp;rsquo;s contumely
The pangs of despised love, the law&amp;rsquo;s delay,
The insolence of office, and the spurns
That patient merit of th&amp;rsquo; unworthy takes,
When he himself might his quietus make
With a bare bodkin? Who would fardels bear,
To grunt and sweat under a weary life,
But that the dread of something after death,
The undiscovered country, from whose bourn
No traveller returns, puzzles the will,
And makes us rather bear those ills we have
Than fly to others that we know not of?
Thus conscience does make cowards of us all,
And thus the native hue of resolution
Is sicklied o&amp;rsquo;er with the pale cast of thought,
And enterprise of great pitch and moment
With this regard their currents turn awry
And lose the name of action. &amp;ndash; Soft you now,
The fair Ophelia! &amp;ndash; Nymph, in thy orisons
Be all my sins remembered.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Dear diary</title>
      <link>http://randomcanary.github.io/post/2015-01-27-dear-diary/</link>
      <pubDate>Tue, 27 Jan 2015 00:00:00 +0000</pubDate>
      
      <guid>http://randomcanary.github.io/post/2015-01-27-dear-diary/</guid>
      <description>&lt;p&gt;What is it with that Mary girl?  Dragging me to school every day. As if I had a choice.  What you don&amp;rsquo;t hear in those nursery rhymes is that she starves me if I don&amp;rsquo;t go to school with her; it&amp;rsquo;s the only way I can stay alive!  I&amp;rsquo;m thinking about being adopted by Little Bo Peep, sure I may get lost, but anything is better than being with Mary and those little brats at school (shudder, shudder).&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Soccer</title>
      <link>http://randomcanary.github.io/post/2015-01-19-soccer/</link>
      <pubDate>Mon, 19 Jan 2015 00:00:00 +0000</pubDate>
      
      <guid>http://randomcanary.github.io/post/2015-01-19-soccer/</guid>
      <description>&lt;p&gt;From Wikipedia:&lt;/p&gt;

&lt;p&gt;Association football, more commonly known as football or soccer,[2] is a sport played between two teams of eleven players with a spherical ball. It is played by 250 million players in over 200 countries, making it the world&amp;rsquo;s most popular sport.[3][4][5][6] The game is played on a rectangular field with a goal at each end. The object of the game is to score by getting the ball into the opposing goal.&lt;/p&gt;

&lt;p&gt;The goalkeepers are the only players allowed to touch the ball with their hands or arms while it is in play and then only in their penalty area. Outfield players mostly use their feet to strike or pass the ball, but may use their head or torso to strike the ball instead. The team that scores the most goals by the end of the match wins. If the score is level at the end of the game, either a draw is declared or the game goes into extra time and/or a penalty shootout depending on the format of the competition. The Laws of the Game were originally codified in England by The Football Association in 1863. Association football is governed internationally by the International Federation of Association Football (FIFA; French: Fédération Internationale de Football Association) which organises a World Cup every four years.[7]&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Pirates arrrr</title>
      <link>http://randomcanary.github.io/post/2015-01-15-pirates/</link>
      <pubDate>Thu, 15 Jan 2015 00:00:00 +0000</pubDate>
      
      <guid>http://randomcanary.github.io/post/2015-01-15-pirates/</guid>
      <description>&lt;p&gt;Piracy is typically an act of robbery or criminal violence at sea. The term can include acts committed on land, in the air, or in other major bodies of water or on a shore. It does not normally include crimes committed against persons traveling on the same vessel as the perpetrator (e.g. one passenger stealing from others on the same vessel). The term has been used throughout history to refer to raids across land borders by non-state agents.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>First post!</title>
      <link>http://randomcanary.github.io/post/2015-01-04-first-post/</link>
      <pubDate>Mon, 05 Jan 2015 00:00:00 +0000</pubDate>
      
      <guid>http://randomcanary.github.io/post/2015-01-04-first-post/</guid>
      <description>

&lt;h3 id=&#34;big-oh-revision:95fc4c9ba4fb901bc95696c988fc4f22&#34;&gt;Big Oh Revision&lt;/h3&gt;

&lt;p&gt;Big O Revision : consider any function, say &lt;code&gt;$f = 2n^2 + 7$&lt;/code&gt; : we say f belongs to a function or a set of functions such that all these functions grow weakly faster than f. This set of functions is O(f). For example, we can say Big Oh of f is $n^2$. Formally, we say can $C.n^2$ grows faster than f, or is greater than f for some value of C, a positive number?&lt;/p&gt;

&lt;p&gt;Certainly! Hence, $O(f) = n^2$  . However, $O(n^2) = [n^2, n^3$,&amp;hellip;] and so on, so O(f) is actually a whole set of functions, of which $n^2$ is the closest to f, or the &lt;em&gt;tightest bound&lt;/em&gt;.&lt;br /&gt;
Formally, the definition of Big Oh is, a function $b \in O(f) \iff f \leq C.b$&lt;/p&gt;

&lt;p&gt;$O(f)$ is an upper bound on f. Similarily $\Omega(f)$ is  a lower bound on f. In other words, a function $b \in \Omega(f) \iff f \geq C.b$ for all inputs, for some value of C.&lt;/p&gt;

&lt;h3 id=&#34;sorting-bubble-merge-and-quicksort:95fc4c9ba4fb901bc95696c988fc4f22&#34;&gt;Sorting : Bubble, Merge and Quicksort&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def bubbleSort(inp):
    n = len(inp)
    for i in range(n-1, 0, -1):
        for j in range(i):
            if inp[j] &amp;gt; inp[j+1]:
                inp[j], inp[j+1] = inp[j+1], inp[j]                
    return inp

print bubbleSort([9,2,6,1])
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;([1, 2, 6, 9], 1)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# [6, 3, 7, 2]

#[1, 3] , [2, 4]
def merge(list1, list2):
    i, j = 0,0
    merged_list = []
    
    while i &amp;lt; len(list1)  and j &amp;lt; len(list2):
        print &amp;quot;i is {} and j is {}&amp;quot;.format(i, j)
        if list1[i] &amp;lt; list2[j]:
            merged_list.append(list1[i])
            i+= 1
        else:
            merged_list.append(list2[j])
            j+= 1      
    
    merged_list.extend(list1[i:])
    merged_list.extend(list2[j:])
    
    return merged_list
        
def mergesort(input):
    if len(input) &amp;lt;= 1:
        return input
    midpt = int(len(input)/2)
    return merge(mergesort(input[:midpt]), mergesort(input[midpt:]))

print mergesort([9,2,6,1])
    
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;i is 0 and j is 0
i is 0 and j is 0
i is 0 and j is 0
i is 0 and j is 1
i is 1 and j is 1
[1, 2, 6, 9]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# quicksort  # pick pivot to be [0]
def quicksort(inp):
    if len(inp) &amp;lt;= 1:
        return inp
    left = [x for x in inp if x &amp;lt; inp[0]]
    right = [x for x in inp if x &amp;gt; inp[0]]
    pivot_list = [x for x in inp if x == inp[0]]
    return quicksort(left) + pivot_list + quicksort(right) 

print quicksort([9,2,6,1])

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;[1, 2, 6, 9]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# in place quicksort
#[9,2,6,1,5]
# pivot&#39;s the last element for convenience
def quicksort_ip(inp, start, end):
    if start &amp;gt;= end:
        return
    
    pivot = inp[end]
    border = start
    for i in range(start, end):
        if inp[i] &amp;lt; pivot:
            inp[i], inp[border] = inp[border], inp[i]
            border += 1
    inp[border], inp[end] = inp[end], inp[border]
    quicksort_ip(inp, start, border-1)
    quicksort_ip(inp, border+1, end)
    

inp = [9,2,6,1]
quicksort_ip(inp, 0, len(inp)-1)
print inp
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;[1, 2, 6, 9]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# simple ver. of knapsack : values = cost, for all items
import itertools

items = [3, 3, 5, 8]

def solve_knapsack(items, capacity):
    num_items = len(items)
    for i in range(1, num_items + 1):
        combinations = itertools.combinations(items, i)
        for element in combinations:
            if sum([x for x in element]) &amp;lt;= capacity:
                
        
        
    
    
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;maxweight = 10
items = [3, 3, 5, 8]
bestvalues = [[0] * (maxweight + 1)
                  for i in xrange(len(items) + 1)]

print len(bestvalues[0])


&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;11
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# coin change problem

change_amt = 200
coinz = [1, 2, 5, 10, 20, 50, 100, 200]

num_ways_matrix = [[0]*(change_amt+1) for x in range(len(coinz)+1)]

# init pop of matrix
num_ways_matrix[0] = [1] * len(num_ways_matrix[0])


&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def getWayzDynP(coinz, target):
	# create matrix
	m = []
	cols = len(coinz)
	rows = target+1
	for i in range(rows):
		m.append([0]*cols) # We create and initialize our matrix with all 0s.
	# init values for dyn
	m[0] = [1]*cols # First row: all 1s
	for i in range(rows):
		m[i][0] = 1 # First col (1 penny) - all 1s
	# Now to populate the rest of the matrix
	for r in range(1, rows):
		for c in range(1, cols):
			if r &amp;lt; coinz[c]:
				m[r][c] = m[r][c-1]
			else:
				m[r][c] = m[r][c-1] + m[r-coinz[c]][c]	
	return m[target][cols-1]			

coinz = [1, 2, 5, 10, 20, 50, 100, 200]
print &amp;quot;hello&amp;quot;
print getWayzDynP(coinz,200)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;hello
73682
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;coinz = [200, 100, 50, 20, 10, 5, 2, 1]
def getWaysRecursive(target, coin_index):
 n = len(coinz)
 sum = 0 # number of ways - our answer
 for i in range(coin_index, n): #check for all ways using coin i and below.
  if target - coinz[i] == 0: sum+=1 # target&#39;s fully represented
  elif target - coinz[i] &amp;gt; 0: # there&#39;s something left over
   sum += getWaysRecursive(target - coinz[i], i)  
 return sum
            
print getWaysRecursive(7, 6)            
 
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;4
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#balance weights problem v1 : Use *all* the weights to balance the target. 
import itertools
weights = [1, 5]
target = 6

#brute force # we add 6 to the set, generate all possible sets, get their mirror sets, and see if they total up to the same. 
# This is the 2-partition problem bc if we divide the list into two groups, 6 *must* be strictly in one of them. 

# returns the two partitions of the input set if possible, else returns   
def balance_weights_bruteforce(weights, target):
    new_weights = weights[:]
    new_weights.append(target)
    # initial check
    if sum(new_weights) &amp;amp; 1:
        return None
    n = len(new_weights)
    all_the_sublists = itertools.chain.from_iterable(itertools.combinations(new_weights, i) for i in range(1, n))
    for sublist in all_the_sublists:
        #generate mirror set
        mirror_sublist = [x for x in new_weights if x not in sublist]
        if sum(sublist) == sum(mirror_sublist):
            return (sublist), (mirror_sublist)
    return None

print balance_weights_bruteforce(weights, target)

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;((6,), [1, 5])
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;weights = [3, 4, 1]
target = 6

def balance_weights_recursive_init(weights, target):
    new_weights = weights[:]
    new_weights.append(target)
    # initial check
    if sum(new_weights) &amp;amp; 1:
        return None
    new_weights.sort(reverse=True)
    
    new_target = sum(new_weights) / 2
    return balance_weights_recursive(new_weights, new_target)

def balance_weights_recursive(weights, target):
    sublist = []
    for i, v in enumerate(weights):
        if target - wt == 0:
            sublist += [wt]
        elif target - wt &amp;gt; 0:
            sublist += balance_weights_recursive(weights, target - wt) 
        
    return sublist      
        
    
print balance_weights_recursive(weights, target)    

    
    
    
    
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;[3, 1, 1, 1, 1, 1, 4, 3, 1]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Q1 :
Rate limiting alg
Q2a :
Given n, print out all the valid ways you can print open and close brackets. For eg, n=2, we can have ()(), (())
Ans. hint : make rules : we have 2 rules here: (1) If |O| &amp;lt; n, then O is possible, (2)&amp;hellip;&lt;/p&gt;

&lt;p&gt;Q2b: Given a keyboard&lt;/p&gt;

&lt;p&gt;A B C D E&lt;/p&gt;

&lt;p&gt;F G H I J&lt;/p&gt;

&lt;p&gt;K L M N O&lt;/p&gt;

&lt;p&gt;P Q R S T&lt;/p&gt;

&lt;p&gt;U V W X Y&lt;/p&gt;

&lt;p&gt;Z&lt;/p&gt;

&lt;p&gt;given a word (&amp;ldquo;CARS&amp;rdquo;), create a path from one letter to another. Start at A. For eg., &amp;ldquo;CA&amp;rdquo; is Start-&amp;gt;C-&amp;gt;A giving a path like &amp;ldquo;RR!LL!&amp;rdquo; where ! marks a period.&lt;/p&gt;

&lt;p&gt;Q3: Given a sorted list [1 2 3 4 5], that has been broken at some one point and put together incorrectly [4 5 1 2 3], write a findItem(item) method.
Ans. hint : Brute force for findItem takes O(n). But binary search on a sorted list takes log(n). So the trick is to find the boundary where the list is broken.&lt;/p&gt;

&lt;p&gt;Q4: Systems design: You want an API to serve a Yes/No answer whether an ad should be accepted: an ad id and cost is mentioned, and the API checks it against that ad&amp;rsquo;s budget and if below or equal to the budget, replies with a Yes, else No. The API is distributed (like a CDN) and latency is more important than accuracy. Design and discuss.&lt;/p&gt;

&lt;p&gt;Q5: Given a list of lists of strings L = L1, L2, &amp;hellip;. where Lx = s1, s2, s3, &amp;hellip; , list all elements that appear in in only one list.&lt;/p&gt;

&lt;p&gt;Q5a: Is the lists are so large that only one can fit on one machine, how would you amend your code?&lt;/p&gt;

&lt;h3 id=&#34;bellman-ford-moore-algorithm:95fc4c9ba4fb901bc95696c988fc4f22&#34;&gt;Bellman-Ford-Moore Algorithm&lt;/h3&gt;

&lt;h3 id=&#34;hackerrank-revision:95fc4c9ba4fb901bc95696c988fc4f22&#34;&gt;HackerRank Revision&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import time
def t(f, *args):
    t1 = time.time()
    ans = f(*args)
    t2 = time.time()
    return &amp;quot;Ans is {} and time taken is {} ms&amp;quot;.format(ans, t2-t1)

def addAllTheElements(arr):
    sum = 0
    for element in arr:
        sum += element
    return sum 




inp = [3, 300023, 5453544566, 6565665, 34423434]
#print t(addAllTheElements, inp)

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)

&amp;lt;ipython-input-6-4a6dda2ba609&amp;gt; in &amp;lt;module&amp;gt;()
     21 
     22 total = 0
---&amp;gt; 23 map(summ, total, inp )


TypeError: argument 2 to map() must support iteration
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Q2a : Given n, print out all the valid ways you can print open and close brackets. For eg, n=2, we can have ()(), (()) Ans. hint : make rules : we have 2 rules here: (1) If |O| &amp;lt; n, then O is possible, (2)&amp;hellip;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 2^(2n) possibilities 
# prune this
# how: Rules : (()) - Valid, ()() - Valid, )()( - Invalid
## Rule 1:  Must start with ( (let&#39;s call ( -- O and ) -- C )
## Rule 2: Must have |O| == |C| = n
## Review rule : Is this enough to catch all cases? Think of an exception: ())(
## Rule 3: At no point, must |C| &amp;gt; |O|. (However at any point before the end, |O| &amp;gt;= |C|)
## Rule 4: Must end with C (IMO,  subsumed in Rules 2-3, so do not consider except as a  final check).
## Final check : Compare with exponential soln with small inputs to check correctness. 


def f(bracket_str, idx, action, o, c, n):
    if idx == 0: # rule 1
        bracket_str[0] = &amp;quot;(&amp;quot;
        o= o+1
        
    elif action == &amp;quot;O&amp;quot;:
        if o &amp;lt; n and o &amp;gt;= c: #rule 2, 3
            bracket_str[idx] = &amp;quot;(&amp;quot;
            o = o+1
    elif action == &amp;quot;C&amp;quot;:
        if c &amp;lt; n and o &amp;gt;= c:
            bracket_str[idx] = &amp;quot;)&amp;quot;
            c = c+1
    else:
        return 
    if idx == 2*n -1:
        if o == c:
            print &#39;&#39;.join(bracket_str)
        else: 
            return    
    else:
        f(bracket_str, idx+1, &amp;quot;O&amp;quot;, o, c, n)
        f(bracket_str, idx+1, &amp;quot;C&amp;quot;, o, c, n)           

def gen_brackets(n):
    bracket_str = [&amp;quot;-&amp;quot; for _ in range(2*n)]
    f(bracket_str, 0, &amp;quot;O&amp;quot;, 0, 0, n)
    
gen_brackets(4)





&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;(((())))
((()()))
((())())
((()))()
(()(()))
(()()())
(()())()
(())(())
(())()()
()((()))
()(()())
()(())()
()()(())
()()()()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Q2b: Given a keyboard&lt;/p&gt;

&lt;p&gt;A B C D E&lt;/p&gt;

&lt;p&gt;F G H I J&lt;/p&gt;

&lt;p&gt;K L M N O&lt;/p&gt;

&lt;p&gt;P Q R S T&lt;/p&gt;

&lt;p&gt;U V W X Y&lt;/p&gt;

&lt;p&gt;Z&lt;/p&gt;

&lt;p&gt;given a word (&amp;ldquo;CARS&amp;rdquo;), create a path from one letter to another. Start at A. For eg., &amp;ldquo;CA&amp;rdquo; is Start-&amp;gt;C-&amp;gt;A giving a path like &amp;ldquo;RR!LL!&amp;rdquo; where ! marks a period.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Make the input in a concrete data structure so we know what we&#39;re dealing with
board = [ [&amp;quot;A&amp;quot;, &amp;quot;B&amp;quot;, &amp;quot;C&amp;quot;, &amp;quot;D&amp;quot;, &amp;quot;E&amp;quot;],
         [&amp;quot;F&amp;quot;, &amp;quot;G&amp;quot;, &amp;quot;H&amp;quot;, &amp;quot;I&amp;quot;, &amp;quot;J&amp;quot;]    ]

# actions : move L, R, U, D
# borders on actions
print ord(&amp;quot;S&amp;quot;) - ord(&amp;quot;R&amp;quot;)
# trace: for &amp;quot;CRS&amp;quot; we start at position 0, we extract &amp;quot;C&amp;quot;, get the abs offset of C (2), translate the 2-(position)
#into RR!, update position to 2, extract &amp;quot;R&amp;quot;, get abs offset of R (17), translate the 17-(2)=15 into
# d = 15/5 =3 ; r = 15%5, update position to 17, extract &amp;quot;S&amp;quot;, get rel. offset ord(&amp;quot;S&amp;quot;)-(position) = 1, translate 
# that into R!

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;1
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Simpler version: board = [&amp;quot;A&amp;quot;, .....&amp;quot;Z&amp;quot;]
def gen_path(inputString):
    position = ord(&amp;quot;A&amp;quot;)
    path = &amp;quot;&amp;quot;
    for i,v in enumerate(inputString):
        offset = ord(v) - position
        if offset &amp;lt; 0:
            path += &#39;&#39;.join([&amp;quot;L&amp;quot; for _ in range(abs(offset))])+&amp;quot;!&amp;quot;
            position = ord(v)
        else:
            path += &#39;&#39;.join([&amp;quot;R&amp;quot; for _ in range(abs(offset))])+&amp;quot;!&amp;quot;
            position = ord(v)
    return path   

print gen_path(&amp;quot;CARS&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;RR!LL!RRRRRRRRRRRRRRRRR!R!
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Now the 2-dim-action version 
def get_current_position(aChar):
    val = ord(aChar) - ord(&amp;quot;A&amp;quot;)
    row_num = int(val/5)
    col_num = val%5
    return row_num, col_num

def gen_step(tuple1, tuple2):
    # U or D?
    up = &#39;&#39;.join([&amp;quot;U&amp;quot; for _ in range(abs(tuple2[0] - tuple1[0])) if tuple2[0] &amp;lt; tuple1[0]])
    down = &#39;&#39;.join([&amp;quot;D&amp;quot; for _ in range(abs(tuple2[0] - tuple1[0])) if tuple2[0] &amp;gt; tuple1[0]])
    right = &#39;&#39;.join([&amp;quot;R&amp;quot; for _ in range(abs(tuple2[1] - tuple1[1])) if tuple2[1] &amp;gt; tuple1[1]])
    left = &#39;&#39;.join([&amp;quot;L&amp;quot; for _ in range(abs(tuple2[1] - tuple1[1])) if tuple2[1] &amp;lt; tuple1[1]])
    
    return up+down+right+left+&amp;quot;!&amp;quot;
            
def gen_path(inputString):
    prev_position = [0, 0]
    path = &amp;quot;&amp;quot;
    for i,v in enumerate(inputString):
        curr_position = get_current_position(v)
        path += gen_step(prev_position, curr_position)
        prev_position = curr_position
    return path   

#print gen_path(&amp;quot;CARS&amp;quot;)

print gen_path(&amp;quot;AZAZAZ&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;!DDDDD!UUUUU!DDDDD!UUUUU!DDDDD!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Q3: Given a sorted list [1 2 3 4 5], that has been broken at some one point and put together incorrectly [4 5 1 2 3], write a findItem(item) method. Ans. hint : Brute force for findItem takes O(n). But binary search on a sorted list takes log(n). So the trick is to find the boundary where the list is broken.&lt;/p&gt;

&lt;p&gt;Ans:&lt;br /&gt;
* basically, a search method when you don&amp;rsquo;t know where the list is broken.
* you use binary search for find the break. The break is one of two elements such that the following condition is violated : (the element to the left is weakly smaller, and the element to the right is weakly bigger).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# eg. 9,10,1,2,3,4,5,6,7,8
def binsearch_break(broken_list):
    idx = int(len(broken_list)/2) 
    while broken_list[idx-1] &amp;lt;= broken_list[idx] and broken_list[idx] &amp;lt;= broken_list[idx+1]:
        if broken_list[idx] &amp;lt; broken_list[0]: # the break is in the left sublist
            idx = int(idx/2)
        else:
            idx = int((idx + len(broken_list)-1)/2)
            
    if broken_list[idx-1] &amp;gt; broken_list[idx]:
        return idx
    else:
        return idx+1
    
a = [8, 8, 9,10,1,2,3,4,5,6,7,8]    
#print binsearch_break(a)    
        
def bin_search_offset(aList, val):
    start_idx = binsearch_break(aList)
    idx = (int(len(aList)/2) + start_idx) % len(aList)
    while aList[(idx + start_idx) % len(aList)] != val:
        if val &amp;lt; aList[idx]:
            idx = int(idx/2)
        else:
            idx = int((idx + len(aList)-1)/2) 
    return idx

print binsearch_break(a)
print bin_search_offset(a, 4)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;4



---------------------------------------------------------------------------

KeyboardInterrupt                         Traceback (most recent call last)

&amp;lt;ipython-input-44-463286030683&amp;gt; in &amp;lt;module&amp;gt;()
     27 
     28 print binsearch_break(a)
---&amp;gt; 29 print bin_search_offset(a, 4)


&amp;lt;ipython-input-44-463286030683&amp;gt; in bin_search_offset(aList, val)
     23             idx = int(idx/2)
     24         else:
---&amp;gt; 25             idx = int((idx + len(aList)-1)/2)
     26     return idx
     27 


KeyboardInterrupt: 
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def f(n, perm=&amp;quot;&amp;quot;):
    if n==0:
        print perm
        return
    f(n-1, perm+&amp;quot;(&amp;quot;)
    f(n-1, perm+&amp;quot;)&amp;quot;)
    return

f(5)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;(((((
(((()
((()(
((())
(()((
(()()
(())(
(()))
()(((
()(()
()()(
()())
())((
())()
()))(
())))
)((((
)((()
)(()(
)(())
)()((
)()()
)())(
)()))
))(((
))(()
))()(
))())
)))((
)))()
))))(
)))))
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;a=&amp;quot;abc&amp;quot;
print a+&amp;quot;x&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;abcx
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def f(n, val=&amp;quot;&amp;quot;):
    if n==0:
        return [val]
    list1 = f(n-1, &amp;quot;(&amp;quot;)
    list2 = f(n-1, &amp;quot;)&amp;quot;)
    return_list = [val+x for x in list1]
    return_list.extend([val+x for x in list2])
    return return_list

print len(f(4))
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;16
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def f(n, k, o=0, c=0, perm =&amp;quot;&amp;quot;):
    if k == 2*n:
        perm +=&amp;quot;(&amp;quot;
        o += 1
        k -= 1
    if c &amp;gt; o:
        return
    if o &amp;gt; n:
        return
    if k==0:
        if o == c:
            print &amp;quot;perm is {}&amp;quot;.format(perm)
            return 
        else:
            return
    f(n, k-1, o+1,c, perm+&amp;quot;(&amp;quot;)
    f(n, k-1,o,c+1, perm+&amp;quot;)&amp;quot;)
    return
f(1, 2*1)    
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;perm is ()
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#find x^n 
# New method! Exponentiation by squaring!
from time import time
#first, O(n) method:
def timeit(fname, *params):
    t1 = time()
    ans = fname(*params)
    t2 = time()
    print &amp;quot;For func {} :  Result is {} and time taken is {}&amp;quot;.format(fname.__name__, ans, t2-t1)

def exp(x,n):
    product = 1
    for i in range(n):
        product *= x
    return product

timeit(exp, 3,101)

#now, O(log(n))!
def exp2(x,n):
    if n ==1:
        return x
    if n ==2:
        return x*x
    
    if n &amp;amp; 1: # odd
        return x*exp2(exp2(x,2),(n-1)/2)
    return exp2(exp2(x,2), n/2)

timeit(exp2, 3,101)
        
        
    
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;For func exp :  Result is 1546132562196033993109383389296863818106322566003 and time taken is 3.19480895996e-05
For func exp2 :  Result is 1546132562196033993109383389296863818106322566003 and time taken is 1.09672546387e-05
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;comments:95fc4c9ba4fb901bc95696c988fc4f22&#34;&gt;Comments:&lt;/h3&gt;

&lt;p&gt;exp2 is faster than exp but not by orders of magnitude. In fact, for several large numbers they are identical. This shows that python is doing some optimization behind the scenes for exp that come close to matching the performance of exp2.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;For func exp :  Result is 1546132562196033993109383389296863818106322566003 and time taken is 3.19480895996e-05&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;For func exp2 :  Result is 1546132562196033993109383389296863818106322566003 and time taken is 1.09672546387e-05&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;what-kind-of-optimization:95fc4c9ba4fb901bc95696c988fc4f22&#34;&gt;What kind of optimization?&lt;/h3&gt;

&lt;p&gt;IMO, almost exactly what&amp;rsquo;s happening in exp2. It says, Aah, we have a loop and a simple function within the loop (multiply with a variable &amp;ldquo;product&amp;rdquo;). I don&amp;rsquo;t know what n is because that&amp;rsquo;s runtime, but I do know I can probably divide it into two, run only one of those iterations, and still get the result with half the computations. Actually, I can keep doing that halving, so effectively, it&amp;rsquo;s Ologn. exp2 is a better version of that halving, that&amp;rsquo;s all. I believe this is called loop unrolling, but not sure.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;a = [1,2,3,1,1]
b = a[0:3]
print b
b[0] = 55
print a

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;[1, 2, 3]
[1, 2, 3, 1, 1]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;K = 3
m = [[None]*K for x in range(K)] 
print m
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;[[None, None, None], [None, None, None], [None, None, None]]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;-1 &amp;amp; 0
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;0
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;divmod(-17,5)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;(-4, 3)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;scores = [3.0, 1.0, 0.2]

import numpy as np
import math

def softmax(x):
    &amp;quot;&amp;quot;&amp;quot;Compute softmax values for each sets of scores in x.&amp;quot;&amp;quot;&amp;quot;
    # TODO: Compute and return softmax(x)
    softmaxes = []
    for element in x:
        new_el = math.exp(element)
        softmaxes.append(new_el)
        print new_el
    denom = sum(softmaxes)
    return [float(i)/float(denom) for i in softmaxes]

print(softmax(scores))
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;20.0855369232
2.71828182846
1.22140275816
[0.8360188027814407, 0.11314284146556011, 0.05083835575299916]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;%matplotlib inline
&amp;quot;&amp;quot;&amp;quot;Softmax.&amp;quot;&amp;quot;&amp;quot;

scores = [3.0, 1.0, 0.2]

import numpy as np
import math

def softmax(x):
    &amp;quot;&amp;quot;&amp;quot;Compute softmax values for each sets of scores in x.&amp;quot;&amp;quot;&amp;quot;
    # TODO: Compute and return softmax(x)
    return np.exp(x) / np.sum(np.exp(x), axis=0)
    
print(softmax(scores))

# Plot softmax curves
import matplotlib.pyplot as plt
x = np.arange(-2.0, 6.0, 0.1)
scores = np.vstack([x, np.ones_like(x), 0.2 * np.ones_like(x)])
#print scores
print np.sum(np.exp(scores), axis=0)
plt.plot(x, softmax(scores).T, linewidth=2)
plt.show()
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;[ 0.8360188   0.11314284  0.05083836]
[   4.07501987    4.08925321    4.10498347    4.12236811    4.1415811
    4.16281475    4.18628155    4.21221638    4.2408788     4.27255567
    4.30756403    4.34625425    4.38901355    4.43626989    4.48849622
    4.54621525    4.61000463    4.68050281    4.75841534    4.844522
    4.93968459    5.0448555     5.16108734    5.28954339    5.43150928
    5.58840586    5.76180339    5.95343729    6.16522552    6.3992877
    6.65796642    6.94385061    7.25980151    7.60898125    7.99488455
    8.42137366    8.89271701    9.41363198    9.98933205   10.62557903
   11.32874069   12.1058545    12.96469809   13.91386704   14.96286097
   16.12217855   17.40342262   18.81941631   20.38433136   22.11382996
   24.02522151   26.13763587   28.47221478   31.05232351   33.90378463
   37.05513655   40.53791903   44.38698895   48.64086908   53.34213369
   58.53783462   64.27997218   70.62601563   77.63947829   85.39055325
   93.95681589  103.42400023  113.88685704  125.45010211  138.22946427
  152.35284369  167.96159189  185.21192646  204.27649456  225.34610079
  248.63161685  274.36609201  302.80708555  334.2392445   368.97715245]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;output_38_1.png&#34; alt=&#34;png&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import time
# Paths are chains of elements such that next element &amp;lt; previous element, so..
# Given a node, return just those neighbors whose value &amp;lt; value(node)
def get_neighbors(graph, node): # node is a 2-tuple?
    neighbors = []
    max_x, max_y = graph.shape
    x,y = node
    val = graph[x,y]
    if y &amp;gt; 0:
        left = (x, y-1)
        if graph[left] &amp;lt; val:
            neighbors.append(left)
            
    if y &amp;lt; max_y - 1:
        right = (x, y+1)
        if graph[right] &amp;lt; val:
            neighbors.append(right)
    if x &amp;gt; 0:
        up = (x-1, y)
        if graph[up] &amp;lt; val:
            neighbors.append(up)
            
    if x &amp;lt; max_x - 1:
        down = (x+1, y)
        if graph[down] &amp;lt; val:
            neighbors.append(down)
            
    return neighbors        
    
def dfs_longest_path(graph, start_node):
    unvisited, paths = [start_node], [(start_node,)]
    complete_paths = []
    max_length = 0
    d = {}
    while unvisited:
        current_node = unvisited.pop()
        current_path = paths.pop()    
        children = get_neighbors(graph, current_node)
        if not children: # you&#39;ve reached the end of a path
            if len(current_path) == max_length:
                complete_paths.append(current_path)
            if len(current_path) &amp;gt; max_length:   
                max_length = len(current_path)
                complete_paths = []
                complete_paths.append(current_path)                              
        else:
            for node in children:
                unvisited += [node]
                temp = current_path + (node,)
                paths += [temp]
    return complete_paths     


def run_on_all_nodes(graph):
    rows, cols = graph.shape
    max_length, all_paths = 0, []
    for r in range(rows):
        for c in range(cols):
            for path in dfs_longest_path(graph, (r,c)):
                if len(path) == max_length:
                    all_paths.append(path)
                if len(path) &amp;gt; max_length:
                    max_length = len(path)
                    all_paths = []
                    all_paths.append(path)
    return all_paths                
                    
def get_list_of_vals(graph, l):
    return [[graph[element] for element in some_list] for some_list in l]
 
def compute_largest_drop(l):
    max_drop = 0
    for element in l:
        drop = element[0] - element[-1]
        max_drop = max(max_drop, drop)
    return max_drop


def t(fn, *args):
	t1 = time.time()
	ans = fn(*args)
	t2 = time.time()
	print &#39;time taken is %f and the result is %s&#39; %(t2-t1, ans)


import numpy as np            
inp = np.loadtxt(&#39;input_final.txt&#39;)
#print inp, &amp;quot;\n&amp;quot;
t1 = time.time()
l = get_list_of_vals(inp,  run_on_all_nodes(inp)  )
results =  len(l[0]), int(compute_largest_drop(l))
t2 = time.time()
print &amp;quot;Time taken is {:.2f} seconds and results are {}&amp;quot;.format(t2-t1 , results)
#print inp[3,2]
#print get_neighbors(inp, (0,3))
#print dfs_longest_path(inp, (1,2))
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;Time taken is 24.20 seconds and results are (15, 1422)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>