<!DOCTYPE html>
<html lang="en">

  <head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">

  <title>First post!</title>

  <meta name="author" content="Preet Singh" />
  
  

  <meta name="generator" content="Hugo 0.15" />

  <link rel="alternate" href="http://randomcanary.github.io/index.xml" type="application/rss+xml" title="Random Canary">

  <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" />
  <link rel="stylesheet" href="http://randomcanary.github.io/css/bootstrap.min.css" />
  <link rel="stylesheet" href="http://randomcanary.github.io/css/main.css" />
  <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic" />
  <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" />
  <link rel="stylesheet" href="http://randomcanary.github.io/css/pygment_highlights.css" />
  
  
  <meta property="og:title" content="First post!" />
  <meta property="og:type" content="website" />
  <meta property="og:url" content="/" />
  <meta property="og:image" content="image/fancygopher.jpg" />

  <script type="text/x-mathjax-config">
MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [['$','$'], ['\\(','\\)']],
    displayMath: [['$$','$$'], ['\[','\]']],
    processEscapes: true,
    processEnvironments: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
    TeX: { equationNumbers: { autoNumber: "AMS" },
         extensions: ["AMSmath.js", "AMSsymbols.js"] }
  }
});
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    
    
    
    var all = MathJax.Hub.getAllJax(), i;
    for(i = 0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
});
</script>
  
</head>


  <body>

    <nav class="navbar navbar-default navbar-fixed-top navbar-custom">
  <div class="container-fluid">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#main-navbar">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="http://randomcanary.github.io/">Random Canary</a>
    </div>

    <div class="collapse navbar-collapse" id="main-navbar">
      <ul class="nav navbar-nav navbar-right">
      
        
          <li>
          <a title="Blog" href="/">Blog</a>
  	      </li>
  	    
      
        
          <li>
          <a title="About" href="/page/about/">About</a>
  	      </li>
  	    
      
      </ul>
    </div>

	<div class="avatar-container">
	  <div class="avatar-img-border">
      
          <a title="Random Canary" href="http://randomcanary.github.io/">
              <img class="avatar-img" src="http://randomcanary.github.io/image/fancygopher.jpg" alt="Random Canary" />
          </a>
      
	  </div>
	</div>

  </div>
</nav>


    <div role="main" class="container main-content">

      
        





<header class="header-section ">

<div class="intro-header no-img">
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <div class="post-heading">
          <h1>First post!</h1>
      
      
      
      <span class="post-meta">Posted on January 5, 2015</span>
      
        </div>
      </div>
    </div>
  </div>
</div>
</header>




<div class="container">
  <div class="row">
    <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
      <article role="main" class="blog-post">
          

<h3 id="big-oh-revision:95fc4c9ba4fb901bc95696c988fc4f22">Big Oh Revision</h3>

<p>Big O Revision : consider any function, say <code>$f = 2n^2 + 7$</code> : we say f belongs to a function or a set of functions such that all these functions grow weakly faster than f. This set of functions is O(f). For example, we can say Big Oh of f is $n^2$. Formally, we say can $C.n^2$ grows faster than f, or is greater than f for some value of C, a positive number?</p>

<p>Certainly! Hence, $O(f) = n^2$  . However, $O(n^2) = [n^2, n^3$,&hellip;] and so on, so O(f) is actually a whole set of functions, of which $n^2$ is the closest to f, or the <em>tightest bound</em>.<br />
Formally, the definition of Big Oh is, a function $b \in O(f) \iff f \leq C.b$</p>

<p>$O(f)$ is an upper bound on f. Similarily $\Omega(f)$ is  a lower bound on f. In other words, a function $b \in \Omega(f) \iff f \geq C.b$ for all inputs, for some value of C.</p>

<h3 id="sorting-bubble-merge-and-quicksort:95fc4c9ba4fb901bc95696c988fc4f22">Sorting : Bubble, Merge and Quicksort</h3>

<pre><code class="language-python">def bubbleSort(inp):
    n = len(inp)
    for i in range(n-1, 0, -1):
        for j in range(i):
            if inp[j] &gt; inp[j+1]:
                inp[j], inp[j+1] = inp[j+1], inp[j]                
    return inp

print bubbleSort([9,2,6,1])
</code></pre>

<pre><code>([1, 2, 6, 9], 1)
</code></pre>

<pre><code class="language-python"># [6, 3, 7, 2]

#[1, 3] , [2, 4]
def merge(list1, list2):
    i, j = 0,0
    merged_list = []
    
    while i &lt; len(list1)  and j &lt; len(list2):
        print &quot;i is {} and j is {}&quot;.format(i, j)
        if list1[i] &lt; list2[j]:
            merged_list.append(list1[i])
            i+= 1
        else:
            merged_list.append(list2[j])
            j+= 1      
    
    merged_list.extend(list1[i:])
    merged_list.extend(list2[j:])
    
    return merged_list
        
def mergesort(input):
    if len(input) &lt;= 1:
        return input
    midpt = int(len(input)/2)
    return merge(mergesort(input[:midpt]), mergesort(input[midpt:]))

print mergesort([9,2,6,1])
    
</code></pre>

<pre><code>i is 0 and j is 0
i is 0 and j is 0
i is 0 and j is 0
i is 0 and j is 1
i is 1 and j is 1
[1, 2, 6, 9]
</code></pre>

<pre><code class="language-python"># quicksort  # pick pivot to be [0]
def quicksort(inp):
    if len(inp) &lt;= 1:
        return inp
    left = [x for x in inp if x &lt; inp[0]]
    right = [x for x in inp if x &gt; inp[0]]
    pivot_list = [x for x in inp if x == inp[0]]
    return quicksort(left) + pivot_list + quicksort(right) 

print quicksort([9,2,6,1])

</code></pre>

<pre><code>[1, 2, 6, 9]
</code></pre>

<pre><code class="language-python"># in place quicksort
#[9,2,6,1,5]
# pivot's the last element for convenience
def quicksort_ip(inp, start, end):
    if start &gt;= end:
        return
    
    pivot = inp[end]
    border = start
    for i in range(start, end):
        if inp[i] &lt; pivot:
            inp[i], inp[border] = inp[border], inp[i]
            border += 1
    inp[border], inp[end] = inp[end], inp[border]
    quicksort_ip(inp, start, border-1)
    quicksort_ip(inp, border+1, end)
    

inp = [9,2,6,1]
quicksort_ip(inp, 0, len(inp)-1)
print inp
</code></pre>

<pre><code>[1, 2, 6, 9]
</code></pre>

<pre><code class="language-python"># simple ver. of knapsack : values = cost, for all items
import itertools

items = [3, 3, 5, 8]

def solve_knapsack(items, capacity):
    num_items = len(items)
    for i in range(1, num_items + 1):
        combinations = itertools.combinations(items, i)
        for element in combinations:
            if sum([x for x in element]) &lt;= capacity:
                
        
        
    
    
</code></pre>

<pre><code class="language-python">maxweight = 10
items = [3, 3, 5, 8]
bestvalues = [[0] * (maxweight + 1)
                  for i in xrange(len(items) + 1)]

print len(bestvalues[0])


</code></pre>

<pre><code>11
</code></pre>

<pre><code class="language-python"># coin change problem

change_amt = 200
coinz = [1, 2, 5, 10, 20, 50, 100, 200]

num_ways_matrix = [[0]*(change_amt+1) for x in range(len(coinz)+1)]

# init pop of matrix
num_ways_matrix[0] = [1] * len(num_ways_matrix[0])


</code></pre>

<pre><code class="language-python">def getWayzDynP(coinz, target):
	# create matrix
	m = []
	cols = len(coinz)
	rows = target+1
	for i in range(rows):
		m.append([0]*cols) # We create and initialize our matrix with all 0s.
	# init values for dyn
	m[0] = [1]*cols # First row: all 1s
	for i in range(rows):
		m[i][0] = 1 # First col (1 penny) - all 1s
	# Now to populate the rest of the matrix
	for r in range(1, rows):
		for c in range(1, cols):
			if r &lt; coinz[c]:
				m[r][c] = m[r][c-1]
			else:
				m[r][c] = m[r][c-1] + m[r-coinz[c]][c]	
	return m[target][cols-1]			

coinz = [1, 2, 5, 10, 20, 50, 100, 200]
print &quot;hello&quot;
print getWayzDynP(coinz,200)
</code></pre>

<pre><code>hello
73682
</code></pre>

<pre><code class="language-python">coinz = [200, 100, 50, 20, 10, 5, 2, 1]
def getWaysRecursive(target, coin_index):
 n = len(coinz)
 sum = 0 # number of ways - our answer
 for i in range(coin_index, n): #check for all ways using coin i and below.
  if target - coinz[i] == 0: sum+=1 # target's fully represented
  elif target - coinz[i] &gt; 0: # there's something left over
   sum += getWaysRecursive(target - coinz[i], i)  
 return sum
            
print getWaysRecursive(7, 6)            
 
</code></pre>

<pre><code>4
</code></pre>

<pre><code class="language-python">#balance weights problem v1 : Use *all* the weights to balance the target. 
import itertools
weights = [1, 5]
target = 6

#brute force # we add 6 to the set, generate all possible sets, get their mirror sets, and see if they total up to the same. 
# This is the 2-partition problem bc if we divide the list into two groups, 6 *must* be strictly in one of them. 

# returns the two partitions of the input set if possible, else returns   
def balance_weights_bruteforce(weights, target):
    new_weights = weights[:]
    new_weights.append(target)
    # initial check
    if sum(new_weights) &amp; 1:
        return None
    n = len(new_weights)
    all_the_sublists = itertools.chain.from_iterable(itertools.combinations(new_weights, i) for i in range(1, n))
    for sublist in all_the_sublists:
        #generate mirror set
        mirror_sublist = [x for x in new_weights if x not in sublist]
        if sum(sublist) == sum(mirror_sublist):
            return (sublist), (mirror_sublist)
    return None

print balance_weights_bruteforce(weights, target)

</code></pre>

<pre><code>((6,), [1, 5])
</code></pre>

<pre><code class="language-python">weights = [3, 4, 1]
target = 6

def balance_weights_recursive_init(weights, target):
    new_weights = weights[:]
    new_weights.append(target)
    # initial check
    if sum(new_weights) &amp; 1:
        return None
    new_weights.sort(reverse=True)
    
    new_target = sum(new_weights) / 2
    return balance_weights_recursive(new_weights, new_target)

def balance_weights_recursive(weights, target):
    sublist = []
    for i, v in enumerate(weights):
        if target - wt == 0:
            sublist += [wt]
        elif target - wt &gt; 0:
            sublist += balance_weights_recursive(weights, target - wt) 
        
    return sublist      
        
    
print balance_weights_recursive(weights, target)    

    
    
    
    
</code></pre>

<pre><code>[3, 1, 1, 1, 1, 1, 4, 3, 1]
</code></pre>

<p>Q1 :
Rate limiting alg
Q2a :
Given n, print out all the valid ways you can print open and close brackets. For eg, n=2, we can have ()(), (())
Ans. hint : make rules : we have 2 rules here: (1) If |O| &lt; n, then O is possible, (2)&hellip;</p>

<p>Q2b: Given a keyboard</p>

<p>A B C D E</p>

<p>F G H I J</p>

<p>K L M N O</p>

<p>P Q R S T</p>

<p>U V W X Y</p>

<p>Z</p>

<p>given a word (&ldquo;CARS&rdquo;), create a path from one letter to another. Start at A. For eg., &ldquo;CA&rdquo; is Start-&gt;C-&gt;A giving a path like &ldquo;RR!LL!&rdquo; where ! marks a period.</p>

<p>Q3: Given a sorted list [1 2 3 4 5], that has been broken at some one point and put together incorrectly [4 5 1 2 3], write a findItem(item) method.
Ans. hint : Brute force for findItem takes O(n). But binary search on a sorted list takes log(n). So the trick is to find the boundary where the list is broken.</p>

<p>Q4: Systems design: You want an API to serve a Yes/No answer whether an ad should be accepted: an ad id and cost is mentioned, and the API checks it against that ad&rsquo;s budget and if below or equal to the budget, replies with a Yes, else No. The API is distributed (like a CDN) and latency is more important than accuracy. Design and discuss.</p>

<p>Q5: Given a list of lists of strings L = L1, L2, &hellip;. where Lx = s1, s2, s3, &hellip; , list all elements that appear in in only one list.</p>

<p>Q5a: Is the lists are so large that only one can fit on one machine, how would you amend your code?</p>

<h3 id="bellman-ford-moore-algorithm:95fc4c9ba4fb901bc95696c988fc4f22">Bellman-Ford-Moore Algorithm</h3>

<h3 id="hackerrank-revision:95fc4c9ba4fb901bc95696c988fc4f22">HackerRank Revision</h3>

<pre><code class="language-python">import time
def t(f, *args):
    t1 = time.time()
    ans = f(*args)
    t2 = time.time()
    return &quot;Ans is {} and time taken is {} ms&quot;.format(ans, t2-t1)

def addAllTheElements(arr):
    sum = 0
    for element in arr:
        sum += element
    return sum 




inp = [3, 300023, 5453544566, 6565665, 34423434]
#print t(addAllTheElements, inp)

</code></pre>

<pre><code>---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)

&lt;ipython-input-6-4a6dda2ba609&gt; in &lt;module&gt;()
     21 
     22 total = 0
---&gt; 23 map(summ, total, inp )


TypeError: argument 2 to map() must support iteration
</code></pre>

<p>Q2a : Given n, print out all the valid ways you can print open and close brackets. For eg, n=2, we can have ()(), (()) Ans. hint : make rules : we have 2 rules here: (1) If |O| &lt; n, then O is possible, (2)&hellip;</p>

<pre><code class="language-python"># 2^(2n) possibilities 
# prune this
# how: Rules : (()) - Valid, ()() - Valid, )()( - Invalid
## Rule 1:  Must start with ( (let's call ( -- O and ) -- C )
## Rule 2: Must have |O| == |C| = n
## Review rule : Is this enough to catch all cases? Think of an exception: ())(
## Rule 3: At no point, must |C| &gt; |O|. (However at any point before the end, |O| &gt;= |C|)
## Rule 4: Must end with C (IMO,  subsumed in Rules 2-3, so do not consider except as a  final check).
## Final check : Compare with exponential soln with small inputs to check correctness. 


def f(bracket_str, idx, action, o, c, n):
    if idx == 0: # rule 1
        bracket_str[0] = &quot;(&quot;
        o= o+1
        
    elif action == &quot;O&quot;:
        if o &lt; n and o &gt;= c: #rule 2, 3
            bracket_str[idx] = &quot;(&quot;
            o = o+1
    elif action == &quot;C&quot;:
        if c &lt; n and o &gt;= c:
            bracket_str[idx] = &quot;)&quot;
            c = c+1
    else:
        return 
    if idx == 2*n -1:
        if o == c:
            print ''.join(bracket_str)
        else: 
            return    
    else:
        f(bracket_str, idx+1, &quot;O&quot;, o, c, n)
        f(bracket_str, idx+1, &quot;C&quot;, o, c, n)           

def gen_brackets(n):
    bracket_str = [&quot;-&quot; for _ in range(2*n)]
    f(bracket_str, 0, &quot;O&quot;, 0, 0, n)
    
gen_brackets(4)





</code></pre>

<pre><code>(((())))
((()()))
((())())
((()))()
(()(()))
(()()())
(()())()
(())(())
(())()()
()((()))
()(()())
()(())()
()()(())
()()()()
</code></pre>

<p>Q2b: Given a keyboard</p>

<p>A B C D E</p>

<p>F G H I J</p>

<p>K L M N O</p>

<p>P Q R S T</p>

<p>U V W X Y</p>

<p>Z</p>

<p>given a word (&ldquo;CARS&rdquo;), create a path from one letter to another. Start at A. For eg., &ldquo;CA&rdquo; is Start-&gt;C-&gt;A giving a path like &ldquo;RR!LL!&rdquo; where ! marks a period.</p>

<pre><code class="language-python"># Make the input in a concrete data structure so we know what we're dealing with
board = [ [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;],
         [&quot;F&quot;, &quot;G&quot;, &quot;H&quot;, &quot;I&quot;, &quot;J&quot;]    ]

# actions : move L, R, U, D
# borders on actions
print ord(&quot;S&quot;) - ord(&quot;R&quot;)
# trace: for &quot;CRS&quot; we start at position 0, we extract &quot;C&quot;, get the abs offset of C (2), translate the 2-(position)
#into RR!, update position to 2, extract &quot;R&quot;, get abs offset of R (17), translate the 17-(2)=15 into
# d = 15/5 =3 ; r = 15%5, update position to 17, extract &quot;S&quot;, get rel. offset ord(&quot;S&quot;)-(position) = 1, translate 
# that into R!

</code></pre>

<pre><code>1
</code></pre>

<pre><code class="language-python"># Simpler version: board = [&quot;A&quot;, .....&quot;Z&quot;]
def gen_path(inputString):
    position = ord(&quot;A&quot;)
    path = &quot;&quot;
    for i,v in enumerate(inputString):
        offset = ord(v) - position
        if offset &lt; 0:
            path += ''.join([&quot;L&quot; for _ in range(abs(offset))])+&quot;!&quot;
            position = ord(v)
        else:
            path += ''.join([&quot;R&quot; for _ in range(abs(offset))])+&quot;!&quot;
            position = ord(v)
    return path   

print gen_path(&quot;CARS&quot;)
</code></pre>

<pre><code>RR!LL!RRRRRRRRRRRRRRRRR!R!
</code></pre>

<pre><code class="language-python"># Now the 2-dim-action version 
def get_current_position(aChar):
    val = ord(aChar) - ord(&quot;A&quot;)
    row_num = int(val/5)
    col_num = val%5
    return row_num, col_num

def gen_step(tuple1, tuple2):
    # U or D?
    up = ''.join([&quot;U&quot; for _ in range(abs(tuple2[0] - tuple1[0])) if tuple2[0] &lt; tuple1[0]])
    down = ''.join([&quot;D&quot; for _ in range(abs(tuple2[0] - tuple1[0])) if tuple2[0] &gt; tuple1[0]])
    right = ''.join([&quot;R&quot; for _ in range(abs(tuple2[1] - tuple1[1])) if tuple2[1] &gt; tuple1[1]])
    left = ''.join([&quot;L&quot; for _ in range(abs(tuple2[1] - tuple1[1])) if tuple2[1] &lt; tuple1[1]])
    
    return up+down+right+left+&quot;!&quot;
            
def gen_path(inputString):
    prev_position = [0, 0]
    path = &quot;&quot;
    for i,v in enumerate(inputString):
        curr_position = get_current_position(v)
        path += gen_step(prev_position, curr_position)
        prev_position = curr_position
    return path   

#print gen_path(&quot;CARS&quot;)

print gen_path(&quot;AZAZAZ&quot;)
</code></pre>

<pre><code>!DDDDD!UUUUU!DDDDD!UUUUU!DDDDD!
</code></pre>

<p>Q3: Given a sorted list [1 2 3 4 5], that has been broken at some one point and put together incorrectly [4 5 1 2 3], write a findItem(item) method. Ans. hint : Brute force for findItem takes O(n). But binary search on a sorted list takes log(n). So the trick is to find the boundary where the list is broken.</p>

<p>Ans:<br />
* basically, a search method when you don&rsquo;t know where the list is broken.
* you use binary search for find the break. The break is one of two elements such that the following condition is violated : (the element to the left is weakly smaller, and the element to the right is weakly bigger).</p>

<pre><code class="language-python"># eg. 9,10,1,2,3,4,5,6,7,8
def binsearch_break(broken_list):
    idx = int(len(broken_list)/2) 
    while broken_list[idx-1] &lt;= broken_list[idx] and broken_list[idx] &lt;= broken_list[idx+1]:
        if broken_list[idx] &lt; broken_list[0]: # the break is in the left sublist
            idx = int(idx/2)
        else:
            idx = int((idx + len(broken_list)-1)/2)
            
    if broken_list[idx-1] &gt; broken_list[idx]:
        return idx
    else:
        return idx+1
    
a = [8, 8, 9,10,1,2,3,4,5,6,7,8]    
#print binsearch_break(a)    
        
def bin_search_offset(aList, val):
    start_idx = binsearch_break(aList)
    idx = (int(len(aList)/2) + start_idx) % len(aList)
    while aList[(idx + start_idx) % len(aList)] != val:
        if val &lt; aList[idx]:
            idx = int(idx/2)
        else:
            idx = int((idx + len(aList)-1)/2) 
    return idx

print binsearch_break(a)
print bin_search_offset(a, 4)
</code></pre>

<pre><code>4



---------------------------------------------------------------------------

KeyboardInterrupt                         Traceback (most recent call last)

&lt;ipython-input-44-463286030683&gt; in &lt;module&gt;()
     27 
     28 print binsearch_break(a)
---&gt; 29 print bin_search_offset(a, 4)


&lt;ipython-input-44-463286030683&gt; in bin_search_offset(aList, val)
     23             idx = int(idx/2)
     24         else:
---&gt; 25             idx = int((idx + len(aList)-1)/2)
     26     return idx
     27 


KeyboardInterrupt: 
</code></pre>

<pre><code class="language-python">def f(n, perm=&quot;&quot;):
    if n==0:
        print perm
        return
    f(n-1, perm+&quot;(&quot;)
    f(n-1, perm+&quot;)&quot;)
    return

f(5)
</code></pre>

<pre><code>(((((
(((()
((()(
((())
(()((
(()()
(())(
(()))
()(((
()(()
()()(
()())
())((
())()
()))(
())))
)((((
)((()
)(()(
)(())
)()((
)()()
)())(
)()))
))(((
))(()
))()(
))())
)))((
)))()
))))(
)))))
</code></pre>

<pre><code class="language-python">a=&quot;abc&quot;
print a+&quot;x&quot;
</code></pre>

<pre><code>abcx
</code></pre>

<pre><code class="language-python">def f(n, val=&quot;&quot;):
    if n==0:
        return [val]
    list1 = f(n-1, &quot;(&quot;)
    list2 = f(n-1, &quot;)&quot;)
    return_list = [val+x for x in list1]
    return_list.extend([val+x for x in list2])
    return return_list

print len(f(4))
</code></pre>

<pre><code>16
</code></pre>

<pre><code class="language-python">def f(n, k, o=0, c=0, perm =&quot;&quot;):
    if k == 2*n:
        perm +=&quot;(&quot;
        o += 1
        k -= 1
    if c &gt; o:
        return
    if o &gt; n:
        return
    if k==0:
        if o == c:
            print &quot;perm is {}&quot;.format(perm)
            return 
        else:
            return
    f(n, k-1, o+1,c, perm+&quot;(&quot;)
    f(n, k-1,o,c+1, perm+&quot;)&quot;)
    return
f(1, 2*1)    
</code></pre>

<pre><code>perm is ()
</code></pre>

<pre><code class="language-python">#find x^n 
# New method! Exponentiation by squaring!
from time import time
#first, O(n) method:
def timeit(fname, *params):
    t1 = time()
    ans = fname(*params)
    t2 = time()
    print &quot;For func {} :  Result is {} and time taken is {}&quot;.format(fname.__name__, ans, t2-t1)

def exp(x,n):
    product = 1
    for i in range(n):
        product *= x
    return product

timeit(exp, 3,101)

#now, O(log(n))!
def exp2(x,n):
    if n ==1:
        return x
    if n ==2:
        return x*x
    
    if n &amp; 1: # odd
        return x*exp2(exp2(x,2),(n-1)/2)
    return exp2(exp2(x,2), n/2)

timeit(exp2, 3,101)
        
        
    
</code></pre>

<pre><code>For func exp :  Result is 1546132562196033993109383389296863818106322566003 and time taken is 3.19480895996e-05
For func exp2 :  Result is 1546132562196033993109383389296863818106322566003 and time taken is 1.09672546387e-05
</code></pre>

<h3 id="comments:95fc4c9ba4fb901bc95696c988fc4f22">Comments:</h3>

<p>exp2 is faster than exp but not by orders of magnitude. In fact, for several large numbers they are identical. This shows that python is doing some optimization behind the scenes for exp that come close to matching the performance of exp2.</p>

<p><strong><em>For func exp :  Result is 1546132562196033993109383389296863818106322566003 and time taken is 3.19480895996e-05</em></strong></p>

<p><strong><em>For func exp2 :  Result is 1546132562196033993109383389296863818106322566003 and time taken is 1.09672546387e-05</em></strong></p>

<h3 id="what-kind-of-optimization:95fc4c9ba4fb901bc95696c988fc4f22">What kind of optimization?</h3>

<p>IMO, almost exactly what&rsquo;s happening in exp2. It says, Aah, we have a loop and a simple function within the loop (multiply with a variable &ldquo;product&rdquo;). I don&rsquo;t know what n is because that&rsquo;s runtime, but I do know I can probably divide it into two, run only one of those iterations, and still get the result with half the computations. Actually, I can keep doing that halving, so effectively, it&rsquo;s Ologn. exp2 is a better version of that halving, that&rsquo;s all. I believe this is called loop unrolling, but not sure.</p>

<pre><code class="language-python">a = [1,2,3,1,1]
b = a[0:3]
print b
b[0] = 55
print a

</code></pre>

<pre><code>[1, 2, 3]
[1, 2, 3, 1, 1]
</code></pre>

<pre><code class="language-python">K = 3
m = [[None]*K for x in range(K)] 
print m
</code></pre>

<pre><code>[[None, None, None], [None, None, None], [None, None, None]]
</code></pre>

<pre><code class="language-python">-1 &amp; 0
</code></pre>

<pre><code>0
</code></pre>

<pre><code class="language-python">divmod(-17,5)
</code></pre>

<pre><code>(-4, 3)
</code></pre>

<pre><code class="language-python">scores = [3.0, 1.0, 0.2]

import numpy as np
import math

def softmax(x):
    &quot;&quot;&quot;Compute softmax values for each sets of scores in x.&quot;&quot;&quot;
    # TODO: Compute and return softmax(x)
    softmaxes = []
    for element in x:
        new_el = math.exp(element)
        softmaxes.append(new_el)
        print new_el
    denom = sum(softmaxes)
    return [float(i)/float(denom) for i in softmaxes]

print(softmax(scores))
</code></pre>

<pre><code>20.0855369232
2.71828182846
1.22140275816
[0.8360188027814407, 0.11314284146556011, 0.05083835575299916]
</code></pre>

<pre><code class="language-python">%matplotlib inline
&quot;&quot;&quot;Softmax.&quot;&quot;&quot;

scores = [3.0, 1.0, 0.2]

import numpy as np
import math

def softmax(x):
    &quot;&quot;&quot;Compute softmax values for each sets of scores in x.&quot;&quot;&quot;
    # TODO: Compute and return softmax(x)
    return np.exp(x) / np.sum(np.exp(x), axis=0)
    
print(softmax(scores))

# Plot softmax curves
import matplotlib.pyplot as plt
x = np.arange(-2.0, 6.0, 0.1)
scores = np.vstack([x, np.ones_like(x), 0.2 * np.ones_like(x)])
#print scores
print np.sum(np.exp(scores), axis=0)
plt.plot(x, softmax(scores).T, linewidth=2)
plt.show()
</code></pre>

<pre><code>[ 0.8360188   0.11314284  0.05083836]
[   4.07501987    4.08925321    4.10498347    4.12236811    4.1415811
    4.16281475    4.18628155    4.21221638    4.2408788     4.27255567
    4.30756403    4.34625425    4.38901355    4.43626989    4.48849622
    4.54621525    4.61000463    4.68050281    4.75841534    4.844522
    4.93968459    5.0448555     5.16108734    5.28954339    5.43150928
    5.58840586    5.76180339    5.95343729    6.16522552    6.3992877
    6.65796642    6.94385061    7.25980151    7.60898125    7.99488455
    8.42137366    8.89271701    9.41363198    9.98933205   10.62557903
   11.32874069   12.1058545    12.96469809   13.91386704   14.96286097
   16.12217855   17.40342262   18.81941631   20.38433136   22.11382996
   24.02522151   26.13763587   28.47221478   31.05232351   33.90378463
   37.05513655   40.53791903   44.38698895   48.64086908   53.34213369
   58.53783462   64.27997218   70.62601563   77.63947829   85.39055325
   93.95681589  103.42400023  113.88685704  125.45010211  138.22946427
  152.35284369  167.96159189  185.21192646  204.27649456  225.34610079
  248.63161685  274.36609201  302.80708555  334.2392445   368.97715245]
</code></pre>

<p><img src="output_38_1.png" alt="png" /></p>

<pre><code class="language-python">import time
# Paths are chains of elements such that next element &lt; previous element, so..
# Given a node, return just those neighbors whose value &lt; value(node)
def get_neighbors(graph, node): # node is a 2-tuple?
    neighbors = []
    max_x, max_y = graph.shape
    x,y = node
    val = graph[x,y]
    if y &gt; 0:
        left = (x, y-1)
        if graph[left] &lt; val:
            neighbors.append(left)
            
    if y &lt; max_y - 1:
        right = (x, y+1)
        if graph[right] &lt; val:
            neighbors.append(right)
    if x &gt; 0:
        up = (x-1, y)
        if graph[up] &lt; val:
            neighbors.append(up)
            
    if x &lt; max_x - 1:
        down = (x+1, y)
        if graph[down] &lt; val:
            neighbors.append(down)
            
    return neighbors        
    
def dfs_longest_path(graph, start_node):
    unvisited, paths = [start_node], [(start_node,)]
    complete_paths = []
    max_length = 0
    d = {}
    while unvisited:
        current_node = unvisited.pop()
        current_path = paths.pop()    
        children = get_neighbors(graph, current_node)
        if not children: # you've reached the end of a path
            if len(current_path) == max_length:
                complete_paths.append(current_path)
            if len(current_path) &gt; max_length:   
                max_length = len(current_path)
                complete_paths = []
                complete_paths.append(current_path)                              
        else:
            for node in children:
                unvisited += [node]
                temp = current_path + (node,)
                paths += [temp]
    return complete_paths     


def run_on_all_nodes(graph):
    rows, cols = graph.shape
    max_length, all_paths = 0, []
    for r in range(rows):
        for c in range(cols):
            for path in dfs_longest_path(graph, (r,c)):
                if len(path) == max_length:
                    all_paths.append(path)
                if len(path) &gt; max_length:
                    max_length = len(path)
                    all_paths = []
                    all_paths.append(path)
    return all_paths                
                    
def get_list_of_vals(graph, l):
    return [[graph[element] for element in some_list] for some_list in l]
 
def compute_largest_drop(l):
    max_drop = 0
    for element in l:
        drop = element[0] - element[-1]
        max_drop = max(max_drop, drop)
    return max_drop


def t(fn, *args):
	t1 = time.time()
	ans = fn(*args)
	t2 = time.time()
	print 'time taken is %f and the result is %s' %(t2-t1, ans)


import numpy as np            
inp = np.loadtxt('input_final.txt')
#print inp, &quot;\n&quot;
t1 = time.time()
l = get_list_of_vals(inp,  run_on_all_nodes(inp)  )
results =  len(l[0]), int(compute_largest_drop(l))
t2 = time.time()
print &quot;Time taken is {:.2f} seconds and results are {}&quot;.format(t2-t1 , results)
#print inp[3,2]
#print get_neighbors(inp, (0,3))
#print dfs_longest_path(inp, (1,2))
</code></pre>

<pre><code>Time taken is 24.20 seconds and results are (15, 1422)
</code></pre>

<pre><code class="language-python">
</code></pre>

      </article>

      <ul class="pager blog-pager">
        
        
        <li class="next">
          <a href="http://randomcanary.github.io/post/2015-01-15-pirates/" data-toggle="tooltip" data-placement="top" title="Pirates arrrr">Next Post &rarr;</a>
        </li>
        
      </ul>

      

    </div>
  </div>
</div>

      

      

    </div>

    <footer>
  <div class="container beautiful-jekyll-footer">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <ul class="list-inline text-center footer-links">
          
          
          <li>
            <a href="https://github.com/randomcanary" title="GitHub">
              <span class="fa-stack fa-lg">
                <i class="fa fa-circle fa-stack-2x"></i>
                <i class="fa fa-github fa-stack-1x fa-inverse"></i>
              </span>
            </a>
          </li>
          
		      
          <li>
            <a href="https://twitter.com/singhdaddy" title="Twitter">
              <span class="fa-stack fa-lg">
                <i class="fa fa-circle fa-stack-2x"></i>
                <i class="fa fa-twitter fa-stack-1x fa-inverse"></i>
              </span>
            </a>
          </li>
          
		      
		      
	    	  

    		  <li>
      			<a href="http://randomcanary.github.io/index.xml" title="RSS">
      			  <span class="fa-stack fa-lg">
        				<i class="fa fa-circle fa-stack-2x"></i>
        				<i class="fa fa-rss fa-stack-1x fa-inverse"></i>
      			  </span>
      			</a>
    		  </li>		

        </ul>
        <p class="copyright text-muted">
    		  Preet Singh
    		  &nbsp;&bull;&nbsp;
    		  2016
    		  
    		  
    		  &nbsp;&bull;&nbsp;
    		  <a href="http://randomcanary.github.io/">Random Canary</a>
    		  
  	    </p>
  	        
    		<p class="theme-by text-muted">
    		  Theme by
    		  <a href="http://deanattali.com/beautiful-jekyll/">beautiful-jekyll</a>
    		</p>
      </div>
    </div>
  </div>
</footer>

<script src="http://randomcanary.github.io/js/jquery-1.11.2.min.js"></script>
<script src="http://randomcanary.github.io/js/bootstrap.min.js"></script>
<script src="http://randomcanary.github.io/js/main.js"></script>
<script type="text/javascript"
  src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>



  </body>
</html>
